import e from"semver/ranges/valid";import{semverIntersect as r}from"@voxpelli/semver-set";import n from"jju";import t from"ramda";import{sortPackageJson as i}from"sort-package-json";const o={description:function appendString(e="",r=""){if(e&&r)return`${e} ${r}`;return e||r},main:function replaceString(e="",r=""){return r||e},bin:function mergeBin(e={},r={},n={},t={}){"string"==typeof e&&(e=n.name?{[n.name]:e}:{});"string"==typeof r&&(r=t.name?{[t.name]:r}:{});const i={...e};return Object.keys(r).forEach((e=>{i[e]?i[`${e}-${t.name||0}`]=r[e]:i[e]=r[e]})),i},repository:function mergeRepository(e="",r={}){return e||r},dependencies:mergeDependencies,devDependencies:mergeDependencies,peerDependencies:mergeDependencies,engines:mergeDependencies};function mergeObject(e={},r={}){return{...e,...r}}function mergeDependencies(n={},i={}){return t.isEmpty(n)?i:t.isEmpty(i)?n:mergeObject(n,t.mapObjIndexed(((t,i)=>e(t)&&e(n[i])&&r(t,n[i])||t),i))}function mergeJson(e={},r={}){let n;return n=t.isEmpty(e)?{...r}:t.isEmpty(r)?{...e}:mergeObject(e,t.mapObjIndexed(((n,i)=>{const s=e[i];if(!s)return n;if(Reflect.has(o,i))return o[i](s,n,e,r);const m=typeof s,p=typeof n;return Array.isArray(s)||Array.isArray(n)?function mergeList(e=[],r=[]){return Array.isArray(e)||(e=[e]),Array.isArray(r)||(r=[r]),t.union(e,r)}(s,n):"string"===m&&"string"===p?function mergeString(e="",r=""){return e||r}(s,n):"object"===m&&"object"===p?mergeObject(s,n):(console.warn(`Package Merge Warning: the field "${i}" in two packages are not the same type. (types: ${m},${p})`),n)}),r)),i(n)}const s={mode:"json"};function mergeJsonStr(e,r){return i(n.update(e,mergeJson(n.parse(e,s),n.parse(r,s)),s))}export default mergeJsonStr;export{mergeJson};
